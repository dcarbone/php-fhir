# php-fhir
Tools for creating PHP classes from the HL7 FHIR Specification

If you're looking  to use the classes generated by this library, you may want the
[php-fhir-generated](https://github.com/dcarbone/php-fhir-generated) repo instead.

# Documentation

Please refer to our wiki for the latest documentation: https://github.com/dcarbone/php-fhir/wiki

# V4 Changes

Version 4 of this libary constitutes a near-complete rewrite of the builder and resulting code.  The primary goals
of this rewrite were to:

1. Make constructing types easier / less tedious:
   * Type constructors now have a parameter per field, rather than accepting an nested assocative array of values.
   * Promoting use of PHP 8.0+ named parameters (https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments).
2. Improve performance of generated code.
   * Type properties no longer carry a "default" value of null or empty array.  They are now either set to a non-empty
     value or are not set at all.
   * JSON serialization in particular no longer uses `$out->{self::FIELD_ID} = $v;` syntax for setting fields, favoring setting
     the field directly via `$out->id = $v;`.  In general, more direct use of properties is made.
3. Separate core classes, interfaces, traits, enums, etc., from FHIR resource classes.
   * "Core" classes are now present under the root namespace, with each generated version in a separate sub-namespace.
   * "Version Type" classes are further sub-namespaced under each version namespace to separate them from "Version Core" classes.
4. Provide a basic API client
   * This is still very much a work in progress, but the goal is to provide a simple, easy-to-use API client for FHIR servers.
5. Separate "Core" entities into their own namespace
   * "Core" entities are now separated into common-purpose namespaces, such as `Encoding`, `Client`, `Validation`, etc.
6. Improve and simplify runtime configuration
   * I have created two core config classes:
       * `Encoding\UnserializeConfig` - Configures both JSON and XML unserialization options
       * `Encoding\SerializeConfig` - Configures both JSON and XML serialization options
7. Simplify templates
   * This is still a work in progress, and will probably drastically change again.

## Parsing Example

```php

require 'path to PHPFHIRResponseParserConfig.php';
require 'path to PHPFHIRResponseParser.php';

// build config
$config = new \YourConfiguredNamespace\PHPFHIRConfig([
    'registerAutoloader' => true, // use if you are not using Composer
    'libxmlOpts' => LIBXML_NONET | LIBXML_BIGLINES | LIBXML_PARSEHUGE | LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOXMLDECL // choose different libxml arguments if you want, ymmv.
    'rootXmlns' => 'https://hl7.org/fhir', // a specific root xmlns to use, if the source does not return one
    'overrideSourceXmlns' => true, // set this to true if you want the 'rootXmlns' value you defined to override any value seen from source 
]);

// build parser
$parser = new \YourConfiguredNamespace\PHPFHIRResponseParser($config);

// provide input, receive output.
$object = $parser->parse($yourResponseData);

```

# Serialization

## JSON Serialization

```php
$json = json_encode($object);
```

## XML Serialization

```php
// To get an instance of \XMLWriter...
$xw = $object->xmlSerialize(null, $yourConfigInstance);

// to get as XML string...
$xml = $xw->outputMemory(true);

// you can alternatively have the output written directly to a file:
$xw = new \YourConfiguredNamespace\PHPFHIRXmlWriter();
$xw->openUri('file:///some/directory/fhir-resource.xml');
$object->xmlSerialize($xw, $yourConfigInstance);
```

XML Serialization utilizes [XMLWriter](https://www.php.net/manual/en/book.xmlwriter.php).

# Testing

As part of class generation, a directory & namespace called `PHPFHIRTests` is created under the root namespace and
output directory.

## TODO

- Refactor template system to use Twig.
- Improve template loading and iteration system, too squirrely right now.
- Implement serialization abstraction, allowing for more flexible serialization options.
  - XMLReader / XMLParser pull or event parsing
  - Something like [pcrov/JSONReader](https://github.com/pcrov/JsonReader) for larger JSON responses
- Improved client implementation
  - Allow for persisting to, and parsing from, disk.

## Suggestions and help

