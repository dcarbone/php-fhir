# php-fhir
Tools for creating PHP classes from the HL7 FHIR Specification

If you're looking  to use the classes generated by this library, you may want the
[php-fhir-generated](https://github.com/dcarbone/php-fhir-generated) repo instead.

# Index

1. [Install as Standalone Generator](#install-as-standalone-generator)
2. [Install as Library](#install-as-library)
3. [Version Table](#version-table)
4. [Basic Usage](#basic-usage)
   * [Class Generation](#class-generation)
     * [Generation Example](#generation-example)
   * [Data Querying](#data-querying)
   * [Response Parsing](#response-parsing)
     * [Parsing Example](#parsing-example)
5. [Serializatoin](#serialization)
   * [JSON Serialization](#json-serialization)
   * [XML Serialization](#xml-serialization)
6. [Testing](#testing)

# Install as Standalone Generator
If you wish to use this package as a standalone generator:
 
1. Check out the desired branch or tag
2. Execute `composer install` from root of project directory
3. Execute `./bin/generate.sh`
4. Answer all prompts
   * If no custom configuration file is defined, definitions will be downloaded to `./input` and
classes will be generated under `./output` 
   * You can execute `./bin/generate.sh --help` for details on how to utilize this script
   * You can configure various aspects of this script by altering the values in [./bin/config.php](./bin/config.php)

This script will download configured major versions of FHIR into the `input` folder and
generate classes for every version in the `output` folder.

# Install as Library
If you wish to use the generator as part of a project, you can include it as a composer
dependency:

```shell
composer require dcarbone/php-fhir
```

From there, you can reference the [Example](#generation-example) block for a quick example on how to
configure and execute the generator.

# Version Table

| PHPFHIR Version | PHP Versions | FHIR Versions                    |
|-----------------|--------------|----------------------------------|
| v2              | 5.4-7.4      | DSTU1, DSTU2, STU3, R4 (<v4.3.0) |
| v3              | 8.1+         | DSTU1, DSTU2, STU3, R4, R5       |

# Basic Usage

The first step is to determine the version of the FHIR spec your implementation supports.  Once done, download
the appropriate class definition XSDs from [http://hl7.org/fhir/directory.html](http://hl7.org/fhir/directory.html).

Uncompress the XSD's and place them in a directory that is readable by PHP's runtime user.

Next comes the fun:

## Class Generation

The class generator utility included with this library is designed to parse the XSD's provided by the FHIR
group into PHP classes, complete with markup and type hinting.

There are 2 important things to note with this section:

1. Your exact implementation will probably vary, don't hesitate to ask if you need some help
2. The class generation should be run ONCE per FHIR version.  Once the classes have been generated they should only 
   ever be re-generated if your server switches to a new FHIR spec

### Generation Example

```php
require __DIR__.'/vendor/autoload.php';

$schemaPath = 'schema/path';

// first, build new configuration class
$config = new \DCarbone\PHPFHIR\Config([
    // The path to look look for and optionally download source XSD files to
    'schemaPath'  => __DIR__ . '/../input',

    // The path to place generated type class files
    'classesPath' => __DIR__ . '/../output',

    // If true, will use a noop null logger
    'silent'      => false,

    // If true, will skip generation of test classes
    'skipTests'   => false,

    // Map of versions and configurations to generate
    // Each entry in this map will grab the latest revision of that particular version.  If you wish to use a specific
    // version, please see https://www.hl7.org/fhir/directory.html
    'versions'    => [
        'DSTU1' => [
            // Source URL
            'url'       => 'https://hl7.org/fhir/DSTU1/fhir-all-xsd.zip',
            // Namespace to prefix the generated classes with
            'namespace' => '\\HL7\\FHIR\\DSTU1',
        ],
        'DSTU2' => [
            'url'          => 'https://hl7.org/fhir/DSTU2/fhir-all-xsd.zip',
            'namespace'    => '\\HL7\\FHIR\\DSTU2',
            'testEndpoint' => 'https://hapi.fhir.org/baseDstu2',
        ],
        'STU3'  => [
            'url'          => 'https://hl7.org/fhir/STU3/fhir-all-xsd.zip',
            'namespace'    => '\\HL7\\FHIR\\STU3',
            'testEndpoint' => 'https://hapi.fhir.org/baseDstu3',
        ],
        'R4'    => [
            'url'          => 'https://www.hl7.org/fhir/R4/fhir-all-xsd.zip',
            'namespace'    => '\\HL7\\FHIR\\R4',
            'testEndpoint' => 'https://hapi.fhir.org/baseR4',
        ],
        'R5' => [
            'url'          => 'https://hl7.org/fhir/R5/fhir-all-xsd.zip',
            'namespace'    => '\\HL7\\FHIR\\R5',
            'testEndpoint' => 'https://hapi.fhir.org/baseR5',
        ]
    ],
]);

// next, build definition class
$version_config = new \DCarbone\PHPFHIR\Config\VersionConfig($config, $config->getVersion('R5'));
$definition = new \DCarbone\PHPFHIR\Definition($version_config);
$definition->buildDefinition();

$builder = new \DCarbone\PHPFHIR\Builder($config, $definition);
$builder->render();
```

Using the above code will generate class files under the included [output](./output) directory, under the namespace
` HL7\\FHIR\\{version} `

If you wish the files to be placed under a different directory, pass the path in as the 2nd argument in the
generator constructor.

If you wish the classes to have a different base namespace, pass the desired NS name in as the 3rd argument in the
generator constructor.

## Data Querying

There are a plethora of good HTTP clients you can use to get data out of a FHIR server, so I leave that up to you.

## Response Parsing

As part of the class generation above, a response parsing class called `PHPFHIRResponseParser` will be created
and added into the root namespace directory.  It currently supports JSON and XML response types.

The parser class takes a single optional boolean argument that will determine if it should
attempt to load up the generated Autoloader class.  By default it will do so, but you are free to configure your
own autoloader and not use the generated one if you wish.

## Parsing Example

```php

require 'path to PHPFHIRResponseParserConfig.php';
require 'path to PHPFHIRResponseParser.php';

// build config
$config = new \YourConfiguredNamespace\PHPFHIRResponseParserConfig([
    'registerAutoloader' => true, // use if you are not using Composer
    'sxeArgs' => LIBXML_COMPACT | LIBXML_NSCLEAN // choose different libxml arguments if you want, ymmv.
]);

// build parser
$parser = new \YourConfiguredNamespace\PHPFHIRResponseParser($config);

// provide input, receive output.
$object = $parser->parse($yourResponseData);

```

# Serialization

## JSON Serialization

```php
$json = json_encode($object);
```

## XML Serialization

```php
// To get an instance of \DOMElement...
$element = $object->xmlSerialize();

// to get as XML string...
$xml = $element->ownerDocument->saveXML($element);
```

XML Serialization utilizes [DOM](https://www.php.net/manual/en/book.dom.php).

# Testing

As part of class generation, a directory & namespace called `PHPFHIRTests` is created under the root namespace and
output directory.

## TODO

- Implement event or pull-based XML parsing for large responses

## Suggestions and help

If you have some suggestions for how this lib could be made more useful, more applicable, easier to use, etc, please
let me know.
